"""Plugin implementation for Voice Activity Detection using Silero VAD with SQLite result caching."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/plugin.ipynb.

# %% auto #0
__all__ = ['SileroVADConfig', 'SileroVADPlugin']

# %% ../nbs/plugin.ipynb #fe7e7229
import json
import time
import logging
from dataclasses import dataclass, field
from typing import Dict, Any, Optional, List, Union, Tuple
from pathlib import Path

import numpy as np
import librosa

# Tier 2 Imports
from cjm_media_plugin_system.analysis_interface import MediaAnalysisPlugin
from cjm_media_plugin_system.core import MediaAnalysisResult, TimeRange
from cjm_media_plugin_system.storage import MediaAnalysisStorage

# Plugin System Utils
from cjm_plugin_system.utils.hashing import hash_file, hash_bytes
from cjm_plugin_system.utils.validation import (
    dict_to_config, config_to_dict, dataclass_to_jsonschema,
    SCHEMA_TITLE, SCHEMA_DESC, SCHEMA_MIN, SCHEMA_MAX, SCHEMA_ENUM
)
from .meta import get_plugin_metadata

# Silero Imports
try:
    from silero_vad import load_silero_vad, get_speech_timestamps
    SILERO_AVAILABLE = True
except ImportError:
    SILERO_AVAILABLE = False

# %% ../nbs/plugin.ipynb #b810b57b
@dataclass
class SileroVADConfig:
    """Configuration for Silero VAD parameters."""
    
    threshold: float = field(
        default=0.5,
        metadata={
            SCHEMA_TITLE: "Threshold",
            SCHEMA_DESC: "Speech probability threshold (0.0 - 1.0). Higher values reduce false positives.",
            SCHEMA_MIN: 0.0, SCHEMA_MAX: 1.0
        }
    )
    
    min_speech_duration_ms: int = field(
        default=250,
        metadata={
            SCHEMA_TITLE: "Min Speech Duration (ms)",
            SCHEMA_DESC: "Segments shorter than this will be ignored.",
            SCHEMA_MIN: 0
        }
    )
    
    min_silence_duration_ms: int = field(
        default=100,
        metadata={
            SCHEMA_TITLE: "Min Silence Duration (ms)",
            SCHEMA_DESC: "Silence shorter than this will not split segments.",
            SCHEMA_MIN: 0
        }
    )
    
    speech_pad_ms: int = field(
        default=30,
        metadata={
            SCHEMA_TITLE: "Speech Padding (ms)",
            SCHEMA_DESC: "Padding added to the start/end of each speech segment.",
            SCHEMA_MIN: 0
        }
    )
    
    sampling_rate: int = field(
        default=16000,
        metadata={
            SCHEMA_TITLE: "Sampling Rate",
            SCHEMA_DESC: "Target sampling rate for VAD processing (Silero expects 8k or 16k).",
            SCHEMA_ENUM: [8000, 16000]
        }
    )
    
    use_onnx: bool = field(
        default=True,
        metadata={
            SCHEMA_TITLE: "Use ONNX",
            SCHEMA_DESC: "Use ONNX runtime for inference (faster)."
        }
    )

# %% ../nbs/plugin.ipynb #ea0dda6a
class SileroVADPlugin(MediaAnalysisPlugin):
    """Voice Activity Detection plugin using Silero VAD."""
    
    config_class = SileroVADConfig
    
    def __init__(self):
        """Initialize the Silero VAD plugin."""
        self.logger = logging.getLogger(f"{__name__}.{type(self).__name__}")
        self.config: SileroVADConfig = None
        self._model = None
        self.storage: Optional[MediaAnalysisStorage] = None

    @property
    def name(self) -> str:  # Plugin name identifier
        """Get the plugin name identifier."""
        return "silero-vad"
    
    @property
    def version(self) -> str:  # Plugin version string
        """Get the plugin version string."""
        return "1.0.0"
    
    @property
    def supported_media_types(self) -> List[str]:  # Supported media types
        """Get the list of supported media types."""
        return ["audio", "video"]

    def get_current_config(self) -> Dict[str, Any]:  # Current configuration as dictionary
        """Return current configuration state."""
        return config_to_dict(self.config) if self.config else {}

    def get_config_schema(self) -> Dict[str, Any]:  # JSON Schema for configuration
        """Return JSON Schema for UI generation."""
        return dataclass_to_jsonschema(SileroVADConfig)

    def initialize(
        self,
        config: Optional[Any] = None  # Configuration dataclass, dict, or None
    ) -> None:
        """Initialize or re-configure the plugin (idempotent)."""
        self.config = dict_to_config(SileroVADConfig, config or {})
        
        # Initialize standardized storage
        db_path = get_plugin_metadata()["db_path"]
        self.storage = MediaAnalysisStorage(db_path)
        
        self.logger.info(f"Initialized Silero VAD plugin with threshold={self.config.threshold}")

    def _load_model(self) -> None:
        """Lazy load the Silero model."""
        if self._model is None:
            if not SILERO_AVAILABLE:
                raise ImportError("silero-vad not installed.")
            self.logger.info("Loading Silero VAD model")
            self._model = load_silero_vad(onnx=self.config.use_onnx)
            self.logger.info("Silero VAD model loaded successfully")

    def _load_audio(
        self,
        path: str,      # Path to audio file
        target_sr: int  # Target sampling rate
    ) -> Tuple[np.ndarray, float]:  # (audio array, duration in seconds)
        """Load and normalize audio using librosa."""
        # Use librosa to load (supports many formats)
        y, sr = librosa.load(path, sr=target_sr, mono=True)
        
        # Normalize
        peak = np.max(np.abs(y)) if len(y) else 0.0
        if peak > 0:
            y = y / peak
            
        return y.astype(np.float32), float(len(y) / sr)

    def execute(
        self,
        media_path: Union[str, Path],  # Path to media file to analyze
        force: bool = False,           # If True, ignore cache and re-run
        **kwargs                       # Override config parameters for this run
    ) -> MediaAnalysisResult:  # Analysis result with detected speech segments
        """Run VAD on the audio file."""
        media_path = str(media_path)
        
        # Apply runtime overrides if any
        if kwargs:
            # Create a temporary merged config for this run
            run_config = dict_to_config(SileroVADConfig, {**config_to_dict(self.config), **kwargs})
        else:
            run_config = self.config

        # Hash the config for cache keying
        config_hash = hash_bytes(json.dumps(config_to_dict(run_config), sort_keys=True).encode())
        
        # 1. Check Cache
        if not force:
            cached = self.storage.get_cached(media_path, config_hash)
            if cached:
                self.logger.info(f"Using cached VAD result for {media_path}")
                ranges_data = cached.ranges or []
                return MediaAnalysisResult(
                    ranges=[TimeRange(**r) for r in ranges_data],
                    metadata=cached.metadata or {}
                )

        # 2. Process
        self._load_model()
        
        # Hash the source file before processing
        file_hash = hash_file(media_path)
        
        # Load Audio
        self.logger.info(f"Processing audio: {media_path}")
        wav, duration = self._load_audio(media_path, run_config.sampling_rate)
        
        # Run Inference
        speech_timestamps = get_speech_timestamps(
            audio=wav,
            model=self._model,
            threshold=run_config.threshold,
            sampling_rate=run_config.sampling_rate,
            min_speech_duration_ms=run_config.min_speech_duration_ms,
            min_silence_duration_ms=run_config.min_silence_duration_ms,
            speech_pad_ms=run_config.speech_pad_ms,
            return_seconds=True,  # Critical: We want seconds, not samples
            visualize_probs=False
        )
        
        # Convert to TimeRange DTOs
        ranges = []
        for ts in speech_timestamps:
            ranges.append(TimeRange(
                start=ts['start'],
                end=ts['end'],
                label="speech",
                confidence=1.0  # Silero binary output implies high confidence if passed threshold
            ))
        
        # Calculate total speech duration
        total_speech = sum(r.end - r.start for r in ranges)
        
        metadata = {
            "duration": duration,
            "sample_rate": run_config.sampling_rate,
            "total_speech": total_speech,
            "total_silence": duration - total_speech,
            "segment_count": len(ranges),
            "processed_at": time.time()
        }
        
        self.logger.info(f"Detected {len(ranges)} speech segments ({total_speech:.2f}s speech / {duration:.2f}s total)")

        # 3. Save to Cache
        self.storage.save(
            file_path=media_path,
            file_hash=file_hash,
            config_hash=config_hash,
            ranges=[r.to_dict() for r in ranges],
            metadata=metadata
        )
            
        return MediaAnalysisResult(ranges=ranges, metadata=metadata)

    def is_available(self) -> bool:  # True if Silero VAD is available
        """Check if Silero VAD is available."""
        return SILERO_AVAILABLE

    def cleanup(self) -> None:
        """Clean up resources."""
        if self._model is not None:
            self.logger.info("Unloading Silero VAD model")
            self._model = None
